<!DOCTYPE html>
<html>
<head>
    <meta name="viewport" content="initial-scale=1.0, user-scalable=no">
    <meta charset="utf-8">
    <title>Polylines测试</title>
    <link rel="stylesheet" href="bootstrap.min.css">
    <link rel="stylesheet" href="animate.css">
    <style>
        html, body {
            height: 100%;
            margin: 0;
            padding: 0;
        }

        #map {
            height: 100%;
        }


        .controls {
            margin-top: 10px;
            border: 1px solid transparent;
            border-radius: 2px 0 0 2px;
            box-sizing: border-box;
            -moz-box-sizing: border-box;
            height: 32px;
            outline: none;
            box-shadow: 0 2px 6px rgba(0, 0, 0, 0.3);
        }

        #pac-input {
            background-color: #fff;
            font-family: Roboto;
            font-size: 15px;
            font-weight: 300;
            margin-left: 12px;
            padding: 0 11px 0 13px;
            text-overflow: ellipsis;
            width: 300px;
        }

        .pac-container {
            font-family: Roboto;
        }

        #type-selector {
            color: #fff;
            background-color: #F17C67;
            padding: 5px 11px 0px 11px;
        }

        #type-selector label {
            font-family: Roboto;
            font-size: 13px;
            font-weight: 300;
        }


    </style>
</head>
<body>
<div class="row">
    <input id="pac-input" class="col-md-4 controls" type="text" placeholder="Search Box">
</div>
<div id="map"></div>


<!-- jQuery 2.1.4 -->
<script src="jQuery-2.1.4.min.js"></script>
<!-- Bootstrap 3.3.5 -->
<script src="bootstrap.min.js"></script>
<script src="https://maps.googleapis.com/maps/api/js?key=AIzaSyAC01nTmNbpdoTQ5eu5v9vs1PpVb-Pbpq4&signed_in=true&libraries=drawing,places&callback=initMap"
        async defer></script>
<script>

    var drawingManager;
    var selectedShape;
    var infoWindow;

    function initMap() {
        var map = new google.maps.Map(document.getElementById('map'), {
            center: {lat: 45.419508, lng: -75.678700},
            zoom: 8
        });


        var drawingManager = new google.maps.drawing.DrawingManager({
            drawingMode: google.maps.drawing.OverlayType.null,
            drawingControl: true,
            drawingControlOptions: {
                position: google.maps.ControlPosition.TOP_CENTER,
                drawingModes: [
                    google.maps.drawing.OverlayType.CIRCLE,
                    google.maps.drawing.OverlayType.POLYGON,
                    google.maps.drawing.OverlayType.RECTANGLE
                ]
            },
            circleOptions: {
                strokeColor: '#D7B98E',
                strokeOpacity: 0.8,
                strokeWeight: 3,
                fillColor: '#D7B98E',
                fillOpacity: 0.4,
                draggable: true,
                editable: true

            },
            polygonOptions: {
                strokeColor: '#D7B98E',
                strokeOpacity: 0.8,
                strokeWeight: 3,
                fillColor: '#D7B98E',
                fillOpacity: 0.4,
                draggable: true,
                editable: true
            },
            rectangleOptions: {
                strokeColor: '#D7B98E',
                strokeOpacity: 0.8,
                strokeWeight: 3,
                fillColor: '#D7B98E',
                fillOpacity: 0.4,
                draggable: true,
                editable: true
            }
        });

        drawingManager.setMap(map);


        google.maps.event.addListener(drawingManager, 'overlaycomplete', function (e) {
            if (e.type != google.maps.drawing.OverlayType.MARKER) {
                // Switch back to non-drawing mode after drawing a shape.
                drawingManager.setDrawingMode(null);

                // Add an event listener that selects the newly-drawn shape when the user mouses down on it.
                var newShape = e.overlay;
                newShape.type = e.type;
                google.maps.event.addListener(newShape, 'click', function () {
                    setSelection(newShape);
                });
                setSelection(newShape);
            }
        });

        google.maps.event.addListener(drawingManager, 'drawingmode_changed', clearSelection);
        google.maps.event.addListener(map, 'click', clearSelection);

        // Create the search box and link it to the UI element.
        var input = document.getElementById('pac-input');
        var searchBox = new google.maps.places.SearchBox(input);
        map.controls[google.maps.ControlPosition.TOP_LEFT].push(input);

        // Bias the SearchBox results towards current map's viewport.
        map.addListener('bounds_changed', function () {
            searchBox.setBounds(map.getBounds());
        });

        var markers = [];
        // [START region_getplaces]
        // Listen for the event fired when the user selects a prediction and retrieve
        // more details for that place.
        searchBox.addListener('places_changed', function () {
            var places = searchBox.getPlaces();

            if (places.length == 0) {
                return;
            }

            // Clear out the old markers.
            markers.forEach(function (marker) {
                marker.setMap(null);
            });
            markers = [];

            // For each place, get the icon, name and location.
            var bounds = new google.maps.LatLngBounds();
            places.forEach(function (place) {
                var icon = {
                    url: place.icon,
                    size: new google.maps.Size(71, 71),
                    origin: new google.maps.Point(0, 0),
                    anchor: new google.maps.Point(17, 34),
                    scaledSize: new google.maps.Size(25, 25)
                };

                // Create a marker for each place.
                markers.push(new google.maps.Marker({
                    map: map,
                    icon: icon,
                    title: place.name,
                    position: place.geometry.location
                }));

                if (place.geometry.viewport) {
                    // Only geocodes have viewport.
                    bounds.union(place.geometry.viewport);
                } else {
                    bounds.extend(place.geometry.location);
                }
            });
            map.fitBounds(bounds);
        });
        // [END region_getplaces]


    }


    function clearSelection() {
        if (selectedShape) {
            selectedShape.setEditable(false);
            selectedShape = null;
        }
    }

    function setSelection(shape) {
        clearSelection();
        selectedShape = shape;
        shape.setEditable(true);
        google.maps.event.addListener(selectedShape, 'rightclick', function (e) {
            // Check if click was on a vertex control point
            if (e.vertex == undefined) {
                return;
            }
            //alert(e.vertex);
            //deleteMenu.open(map, selectedShape.getPath(), e.vertex);
            selectedShape.getPath().removeAt(e.vertex);
        });
		
        google.maps.event.addListener(selectedShape, 'click', function(e){
			var infowindow = new google.maps.InfoWindow();
			// Since this polygon has only one path, we can call getPath() to return the
			// MVCArray of LatLngs.
			var vertices = this.getPath();

			var contentString = '<b>Bermuda Triangle polygon</b><br>' +
					'Clicked location: <br>' + e.latLng.lat() + ',' + e.latLng.lng() +
					'<br>';

			// Iterate over the vertices.
			for (var i = 0; i < vertices.getLength(); i++) {
				var xy = vertices.getAt(i);
				contentString += '<br>' + 'Coordinate ' + i + ':<br>' + xy.lat() + ',' +
						xy.lng();
			}

			// Replace the info window's content and position.
			infoWindow.setContent(contentString);
			infoWindow.setPosition(e.latLng);

			infoWindow.open(map);
		});

    }

    function deleteSelectedShape() {
        if (selectedShape) {
            selectedShape.setMap(null);
        }
    }

    /** @this {google.maps.Polygon} */
    function showArrays(event) {
        // Since this polygon has only one path, we can call getPath() to return the
        // MVCArray of LatLngs.
        var vertices = this.getPath();

        var contentString = '<b>Bermuda Triangle polygon</b><br>' +
                'Clicked location: <br>' + event.latLng.lat() + ',' + event.latLng.lng() +
                '<br>';

        // Iterate over the vertices.
        for (var i = 0; i < vertices.getLength(); i++) {
            var xy = vertices.getAt(i);
            contentString += '<br>' + 'Coordinate ' + i + ':<br>' + xy.lat() + ',' +
                    xy.lng();
        }

        // Replace the info window's content and position.
        infoWindow.setContent(contentString);
        infoWindow.setPosition(event.latLng);

        infoWindow.open(map);
    }

</script>
</body>
</html>